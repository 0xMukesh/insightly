package commands

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/0xmukesh/ratemywebsite/internal/helpers"
	"github.com/0xmukesh/ratemywebsite/internal/utils"
	"github.com/briandowns/spinner"
	"github.com/spf13/cobra"
)

type GenerateUxReportCmd struct {
	Cmd  *cobra.Command
	Args []string
}

func (c GenerateUxReportCmd) New() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "gen-ux",
		Short:   "Generate UX reports",
		Example: "something gen-ux [website-url] [file-path]",
		Aliases: []string{"generate-ux", "gux"},
		RunE: func(cmd *cobra.Command, args []string) error {
			c.Cmd = cmd
			c.Args = args

			c.Handler()

			return nil
		},
	}

	cmd.Flags().BoolP("use-pa11y", "", false, "Use pa11y for running accessibility report")
	cmd.Flags().BoolP("save-report", "", false, "Save parsed report in JSON format")
	cmd.Flags().BoolP("use-ai", "", false, "Use LLMs for generating a summary on how to improve the UX and accessiblity")

	return cmd
}

func (c GenerateUxReportCmd) Handler() {
	cmd := c.Cmd
	args := c.Args

	usePa11y, _ := cmd.Flags().GetBool("use-pa11y")
	saveReport, _ := cmd.Flags().GetBool("save-report")
	useAi, _ := cmd.Flags().GetBool("use-ai")
	websiteUrl := args[0]

	if !utils.IsValidUrl(websiteUrl) {
		log.Fatal("invalid url")
	}

	if !helpers.IsNodeInstalled() {
		log.Fatal("node is not installed")
	}

	var accessibilityReport string
	var metrics []string

	if usePa11y {
		if !helpers.IsPa11yInstalled() {
			log.Fatal("pa11y is not installed")
		}

		s := spinner.New(spinner.CharSets[11], 100*time.Millisecond)
		s.Suffix = " generating UX report using pa11y"
		s.Start()
		report, err := helpers.GeneratePa11yReport(websiteUrl)
		s.Stop()
		if err != nil {
			log.Fatal(err.Error())
		}

		buffer := &bytes.Buffer{}
		encoder := json.NewEncoder(buffer)
		encoder.SetEscapeHTML(false)

		if err := encoder.Encode(&report); err != nil {
			log.Fatal(err.Error())
		}

		accessibilityReport = buffer.String()

		if saveReport {
			if err := os.WriteFile("report.json", buffer.Bytes(), 0644); err != nil {
				log.Fatal(err.Error())
			}

			fmt.Println("saved UX report to report.json")
		}
	} else {
		if !helpers.IsLighthouseInstalled() {
			log.Fatal("lighthouse is not installed")
		}

		s := spinner.New(spinner.CharSets[11], 100*time.Millisecond)
		s.Suffix = " generating UX report using lighthouse"
		s.Start()
		report, err := helpers.GenerateLighthouseReport(websiteUrl)
		if err != nil {
			log.Fatal(err.Error())
		}
		s.Stop()

		var (
			total                      float64 = 0.0
			score                              = 0.0
			firstContentfulPaintTime   string  = ""
			largestContentfulPaintTime         = ""
			firstMeaningfulPaintTime           = ""
			speedIndex                         = ""
			totalBlockingTime                  = ""
		)

		var audits []helpers.LighthouseAudit

		for _, v := range report.Audits {
			if v.Id == "first-contentful-paint" {
				firstContentfulPaintTime = fmt.Sprintf("%.2f%s", v.NumericValue, utils.ConvertNumericUnits(v.NumericUnit))
			}

			if v.Id == "largest-contentful-paint" {
				largestContentfulPaintTime = fmt.Sprintf("%.2f%s", v.NumericValue, utils.ConvertNumericUnits(v.NumericUnit))
			}

			if v.Id == "first-meaningful-paint" {
				firstMeaningfulPaintTime = fmt.Sprintf("%.2f%s", v.NumericValue, utils.ConvertNumericUnits(v.NumericUnit))
			}

			if v.Id == "speed-index" {
				speedIndex = fmt.Sprintf("%.2f%s", v.NumericValue, utils.ConvertNumericUnits(v.NumericUnit))
			}

			if v.Id == "total-blocking-time" {
				totalBlockingTime = fmt.Sprintf("%.2f%s", v.NumericValue, utils.ConvertNumericUnits(v.NumericUnit))
			}

			if v.Score != nil {
				score += *v.Score
				total++
				audits = append(audits, v)
			}
		}

		if total != 0 {
			metrics = append(metrics, fmt.Sprintf("%.2f", score/total))
		} else {
			metrics = append(metrics, "0")
		}

		metrics = append(metrics, firstContentfulPaintTime, firstMeaningfulPaintTime, largestContentfulPaintTime, speedIndex, totalBlockingTime)

		auditsBytes, err := json.Marshal(audits)
		if err != nil {
			log.Fatal(err.Error())
		}

		accessibilityReport = string(auditsBytes)

		if saveReport {
			if err := os.WriteFile("report.json", auditsBytes, 0644); err != nil {
				log.Fatal(err.Error())
			}
		}
	}

	if useAi {
		config, err := helpers.ReadConfigFile()
		if err != nil {
			log.Fatal(err.Error())
		}

		if config.Default != helpers.Gemini {
			log.Fatal("only gemini is supported at the moment\n")
		}

		geminiKeyFound := true
		var geminiKey string

		for i := range config.Llms {
			if config.Llms[i].Name == helpers.Gemini {
				geminiKeyFound = true
				geminiKey = config.Llms[i].ApiKey
				break
			}
		}

		if !geminiKeyFound {
			log.Fatal("only gemini is supported at the moment and config file doesn't have gemini api key\n")
		}

		var prompt string

		if usePa11y {
			prompt += "Here is an accessibility report generated by pa11y. It is in JSON format and it contains the `code`, `message` and `context`.\n"
			prompt += fmt.Sprintf("```\n%s```\n", accessibilityReport)
			prompt += "Give suggestions regarding how to improve the accessibility and how to fix the errors mentioned by pa11y. Just only the solutions for those issues and also few other suggestions regarding how to improve the UX and accessiblity. Don't render a table of the JSON input. Just mention solution of every issue in a list style manner."
		} else {
			prompt += "Here is a report with audits generated by lighthouse. It is in JSON format and it contains the `score` (which ranges from 0 to 1) for individual audit\n"
			prompt += fmt.Sprintf("```\n%s```\n", accessibilityReport)
			prompt += "Taking score in consideration, give suggestions on how to improve the accessiblity and UX in the website. Just mention solution in a list styled manner"

			if err := os.WriteFile("prompt.txt", []byte(prompt), 0644); err != nil {
				log.Fatal(err.Error())
			}
		}

		s := spinner.New(spinner.CharSets[11], 100*time.Millisecond)
		s.Suffix = " sending prompt to gemini"
		s.Start()
		output, err := helpers.SendReqToGemini(geminiKey, prompt)
		if err != nil {
			log.Fatal(err.Error())
		}
		s.Stop()

		if !usePa11y {
			output = fmt.Sprintf(`* **Metrics**:
			1. Score - %s
			2. First contentful paint - %s
			3. First meaningful paint - %s
			4. Largest meaningful paint - %s
			5. Speed index - %s
			6. Total blocking time - %s`, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4], metrics[5]) + "\n\n" + output
		}

		vimCommands := strings.Join([]string{
			"set noswapfile",
			"set number",
			"syntax on",
			"set ft=markdown",
			"set autoindent",
			"set conceallevel=2",
			"set background=dark",
			"colorscheme industry",
			"set expandtab",
			"set tabstop=2",
			"set shiftwidth=2",
			"set wrap",
			"set linebreak",
			"set breakindent",
			"hi link markdownError NONE",
			"set cole=2",
			"hi markdownH1 cterm=bold ctermfg=blue",
			"hi markdownH2 cterm=bold ctermfg=cyan",
			"hi markdownLinkText cterm=underline ctermfg=green",
			"hi markdownUrl cterm=underline ctermfg=green",
			"hi markdownCode ctermfg=yellow",
			"hi markdownCodeBlock ctermfg=yellow",
		}, " | ")

		cmd := exec.Command("vim", "-c", vimCommands, "-")
		cmd.Stdin = bytes.NewBufferString(output)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr

		if err := cmd.Run(); err != nil {
			log.Fatal(err.Error())
		}
	}

}
